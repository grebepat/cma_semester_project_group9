---
title: Cycling Secrets
subtitle: Decoding Bike Messenger Paths for Efficiency
author: Maurin Huonder and Patrick Greber
date: "18.06.2024"
format: 
  html:
    code-fold: true
execute:
  warning: false
  message: false
  cache:   true
lang: en  
bibliography: bibliography.bib
---

# Install Packages

```{r install required packages}

#| echo: false
#| warning: false
#| message: false
#| results: 'hide'

options(repos = c(CRAN = "https://cran.rstudio.com"))

install.packages("pacman")
library("pacman")


p_install("dplyr", force = FALSE)
p_install("ggplot2", force = FALSE)
p_install("readr", force = FALSE)
p_install("tidyr", force = FALSE)
p_install("sf", force = FALSE)
p_install("terra", force = FALSE)
p_install("tmap", force = FALSE)
p_install("zoo", force = FALSE)
p_install("units", force = FALSE)
p_install("patchwork", force = FALSE)
p_install("tidyverse", force = FALSE)
p_install("leaflet", force = FALSE)
p_install("shiny", force = FALSE)
p_install("XML", force = FALSE)
p_install("lubridate", force = FALSE)
p_install("ggh4x", force = FALSE)
p_install("forcats", force = FALSE)
p_install("purrr", force = FALSE)
p_install("viridis", force = FALSE)
p_install("httr", force = FALSE)
p_install("hereR", force = FALSE)
p_install("sp", force = FALSE)
p_install("ggpubr", force = TRUE)
p_install("png", force = FALSE)
p_install("grid", force = FALSE)
p_install("raster", force = FALSE)
p_install("gridExtra", force = FALSE)
p_install("RColorBrewer", force = FALSE)


```

# Load libraries

Load necessary libraries

```{r load necessary libraries}

#| echo: false
#| warning: false
#| message: false

library("ggh4x")
library("dplyr")
library("ggplot2")
library("tidyr")
library("sf")
library("sp")
library("terra")
library("tmap")
library("zoo")
library("tidyverse")
library("leaflet")
library("XML")
library("lubridate")
library("forcats")
library("httr")
library("hereR")
library("png")
library("gridExtra")
library("RColorBrewer")


```

# Task 1: Import Express: Bringing GPS Data Onboard

Import gps data from bike messengers

```{r import raw gps data}

#| warning: false
#| message: false
#| results: 'hide'

## generate a list of all filenames including the path from the subfolder they are stored in
file <- list.files("gps_files_shared", recursive = TRUE, pattern = "\\.gpx$", full.names = TRUE)


## Function to extract messenger and id from file path
extract_info <- function(file) {
  messenger <- as.factor(gsub(".*/gps_files_([^/]+)/.*", "\\1", file))
  id <- as.factor(paste(gsub('.*/(.*).gpx','\\1', file), gsub(".*/gps_files_([^/]+)/.*", "\\1", file), sep = "_"))
  list(messenger = messenger, id = id)
}


## Function to process each file
process_file <- function(file) {
  df <- st_read(file, "track_points")
  
  info <- extract_info(file)
  df$messenger <- info$messenger
  df$id <- info$id
  
  df_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326, remove = FALSE)
  df_sf <- st_transform(df_sf, crs = 2056)
  df_sf$shift <- gsub('.*/(.*).gpx','\\1', file)
  df_sf$x <- st_coordinates(df_sf)[,1]
  df_sf$y <- st_coordinates(df_sf)[,2]
  df_sf <- select(df_sf, id, messenger, shift, time, x, y, ele, geometry)
  
  df_sf$origin <- file
  df_sf
}


## Apply the function to each file using purrr's map function
single_routes <- purrr::map(file, process_file)


## Combine all results
all_routes <- do.call(rbind, single_routes)

## Seperate file into raeubertochter and donner
raeubertochter_raw <- filter(all_routes, messenger == "raeubertochter")
donner_raw <- filter(all_routes, messenger == "donner")


## Our raw data covers one shift per messenger, a total of 11'699 fixes were recorded:
### raeubertochter: 23.10.2023, 12:59:44 - 17:51:21, 7102 fixes
### donner: 30.01.2024, 10:21:41 - 22:14:27, 4597 fixes

```

# Task 2: Import Spatial Data

Import spatial data. Geopackage was preprocessed using Quantum GIS Version 3.34.5.

```{r import spatial data}

#| warning: false
#| message: false
#| results: 'hide'

## All Spatial Data is stored in a geopackage called basic_data. Basic_data consists of several layers such as the street network, surface type or housing footprint. The layers were preprocessed and cliped to the extent of the city outline of zurich using Quantum GIS Version 3.34.5


## Show layers in basic_data.gpkg
st_layers("gis_files/basic_data.gpkg")


## Import street network from zurich, based on the swisstlm3d
streets <- read_sf("gis_files/basic_data.gpkg", "street_network_z") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart),
    width = as.numeric(substr(objektart, start = 1, stop = 1)),
  ) |> 
  na.omit()


## Import city border of zurich
outline <- read_sf("gis_files/basic_data.gpkg", "city_outline")


## Import housing footprint of zurich
housing <- read_sf("gis_files/basic_data.gpkg", "housing_footprint") |> 
   select(objektart, geom) |>
  mutate(
    objektart = as.factor(objektart)
  )


## Import surface type of zurich
surface <- read_sf("gis_files/basic_data.gpkg", "surface_type") |> 
   select(art, geom) |> 
  mutate(
    art = as.factor(art)) |> 
 filter(art == "fliessendes Gewässer" | art == "stehendes Gewässer" | art == "Strasse, Weg" | art == "Verkehrsinsel") |> 
  na.omit()


## Import digital height model DHM25, a set of data representing the 3D form of the earth’s surface without vegetation and buildings
height <- terra::rast("gis_files/dhm25_zh.tif")


```

## Visualize raw Data

Visualize raw GPS data of both messengers using a simple ggplot.

```{r visualize raw data via ggplot, out.width=100, dpi=300}

#| layout-ncol: 2
#| fig-cap: 
#|   - "Line Plot 1"
#|   - "Line Plot 2"

## Visualize the raw gps data from each messenger


### Raeubertochter
p_raw_raeubertochter <- ggplot() +
  geom_sf(data = outline, alpha = 0) +
  geom_sf(data = raeubertochter_raw, aes(color = "red"), size = 0.6) +
  coord_sf(datum = st_crs(2056)) +
  labs(x = "E",
       y = "N") +
    theme_minimal() +
  theme(
    legend.position = "none"
  ) +
  labs(title = "Raeubertochter")


### Donner
p_raw_donner <- ggplot() +
  geom_sf(data = outline, alpha = 0) +
  geom_sf(data = donner_raw, aes(color = "red"), size = 0.6) +
  coord_sf(datum = st_crs(2056)) +
  labs(x = "E",
       y = "N") +
  theme_minimal() +
  theme(
    legend.position = "none"
  ) +
  labs(title = "Donner")

## Arrange plots together
grid.arrange(p_raw_raeubertochter,p_raw_donner, nrow=1, ncol=2)


```

Subsample of raw data in a smaller spatial context

```{r visualize raw data via tmap and spatial context, out.width=100, dpi=300}

#| fig-cap: 
#|   - "Line Plot 1"
#|   fig-width: 8
#|   fig-height: 6
#|   fig-dpi: 500



## Next, we want to visualize a subsample of our raw data in a smaller spatial context
## visualize Subsample in spatial context


## fixing an extent for a subsample of raeubertochter
coords <- rbind(c(2681695, 1247822), c(2683188, 1247822), c(2683188, 1246616), c(2681695, 1246616), c(2681695, 1247822))


## create an extent polygon
polygon <- st_polygon(list(coords))


## convert to spatial object
extent_raeubertochter <- st_sfc(polygon, crs = 2056)


## clip spatial data to extent to reduce data points and speed up computing
housing_raeubertochter <- st_intersection(housing, extent_raeubertochter)
streets_raeubertochter <- st_intersection(streets, extent_raeubertochter)
surface_raeubertochter <- st_intersection(surface, extent_raeubertochter)
raeubertochter_ext <- st_intersection(raeubertochter_raw, extent_raeubertochter)


## Reduce data set to every second gps fix to get a better overview
subset_raeubertochter_raw <- raeubertochter_ext[seq(1, nrow(raeubertochter_ext), by = 2), ]


## map including spatial context of zurich

tmap_mode("plot")
tm_raw_context <- tm_shape(streets_raeubertochter, bbox = extent_raeubertochter) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing_raeubertochter, bbox = extent_raeubertochter) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(subset_raeubertochter_raw, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.6, col = "red",  alpha = 0.7, border.col = "red", legend.col.show = FALSE) +
  tm_layout(frame = FALSE)


## show map
print(tm_raw_context)


## save as a png
# tmap_save(tm_raw_context, "raeubertochter_raw.png", width = 250, height = 200, dpi = 250, units = "mm")

```

Visualize raw data via interactive map

```{r visualize raw data via interactive map}

## Browse trough raw_data

raw_data <- all_routes[seq(1, nrow(all_routes), by = 2), ]

tmap_mode("view")

tm_shape(raw_data) +
  tm_symbols(size = .25, col = "messenger",  alpha = 0.7, legend.col.show = FALSE, palette = c("red", "yellow"), border.col = "black", border.lwd = 0.1) +
  tm_layout(frame = FALSE) +
  tm_basemap(server = "CartoDB.PositronNoLabels", alpha = 0.75) +
  tm_view(symbol.size.fixed = F) +
  tm_facets(by = "messenger", sync = TRUE, ncol = 2)


```

# Task 3: Signal Sync: Assessing Sampling Intervals Across Messenger GPS Systems

```{r assessing sampling intervals}

## If a larger sampling grid is needed: selecting every 10th row from  movement data:
###all_routes <- all_routes[seq(from = 1, to = #nrow(all_routes), by = 5), ]


## calculate rowwise time difference
all_routes <- all_routes |> 
    group_by(id) |> 
    mutate(
    time_difference = as.numeric(difftime(time, lag(time), units = "secs"))) |>
    ungroup()


## How do the time difference differ between messengers?
all_routes |> 
  group_by(id) |> 
  filter(time_difference <= 30) |> # remove outliers to get a clearer view on the average sampling intervall
  summarise(
    mean <- mean(time_difference, na.rm = T)
    )

## Both with similair time difference between fixes, raeubertochter with slightly shorter intervalls


## max value between two fixes, in min
max(all_routes$time_difference, na.rm = T) / 60

## max time difference at 50min

```

Visualize sampling intervall

```{r visualize sampling intervals via ggplot}

#| fig-cap: 
#|   - "Line Plot 1"
#|   fig-width: 8
#|   fig-height: 6


## Quick overview how time differences distribute
p_sampling_interval <- ggplot(all_routes, aes(x = time_difference)) +
  geom_histogram(binwidth = 0.25, col = "white", fill = "grey25") +
  scale_y_log10() +
  scale_x_log10() +
  labs(x = "Time Difference in sec. (Log Scale)", y = "Count (Log Scale)") +
  ggtitle("Histogram of Time Differences with Log Y Axis and Log X Axis") +
  facet_wrap(all_routes$id) +
  theme_minimal()


## show histogram
print(p_sampling_interval)

# Both with similar but slightly different sampling regimes, raeubertochter with an intervall of ~1 second. It seems that static time is already removed in here dataset -> strava data! Most time differences between 1 and 10 seconds, some outliers at more than 1000 seconds

# Donner with more variation between fixes, but still short intervals, might need another segmentation...

```

# Task 4: From Dots to Drops: Segmenting GPS Fixes into Deliveries

```{r segmenting deliveries}

## For seperating the gps data into different segments, we analyse time differences between them. As strava data already removes most of the static points we're in no need to calculate mean_step's but can solely relay on big time gaps.


## create a moving time window
all_routes_seg <- all_routes |> 
   group_by(id) |> 
   mutate(
        nMinus2 = difftime(time, lag(time, 2)), 
        nMinus1 = difftime(time, lag(time,1)),  
        nPlus1  = difftime(lead(time, 1), time), 
        nPlus2  = difftime(lead(time, 2), time)  
    )


## calculate rowwise mean distance per messenger
all_routes_seg <- all_routes_seg |> 
    group_by(id) |>
    mutate(
        timeMean = (nMinus2 + nMinus1 + nPlus1 + nPlus2) / 4
    ) |>
    ungroup()


## create a new column static, based on time_difference (over 20s time difference)
all_routes_seg <- all_routes_seg |> 
  mutate(new_segment = timeMean > 20)

## As strava already removed most static points, we're able to seperate segments via time_difference only. We work with a treshold t of 20 seconds.


## it assigns unique IDs based on the column static
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}


## removes static rows
all_routes_seg <- all_routes_seg |>
    mutate(temp_id = rle_id(new_segment)) |> 
    filter(!new_segment)


## remove segments shorter than two minuntes
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id) |> 
  mutate(duration = difftime(max(time), min(time))
  ) |> 
  filter(!duration < 120) |> 
  ungroup()


## Assining new segment_id starting at one, credits to: https://stackoverflow.com/questions/39650511/r-group-by-variable-and-then-assign-a-unique-id
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id, messenger) |> 
  mutate(segment_id = as_factor(cur_group_id())) |> 
  ungroup() |> 
  select(-temp_id)


## how many segments have been differentiated?
all_routes_seg |> 
  group_by(messenger) |> 
  summarise(length(unique(segment_id)))

## donner with 36 deliveries
## raeubertochter with 22 deliveries


## filter segments according to messenger
raeubertochter_seg <- filter(all_routes_seg, messenger == "raeubertochter")
donner_seg <- filter(all_routes_seg, messenger == "donner")


```

## Visualize Segmented Trajectories

Visualize segmented GPS data of both messengers using a simple ggplot.

```{r visualize segmented data via ggplot}

#| layout-ncol: 2
#| fig-cap: 
#|   - "Line Plot 1"
#|   - "Line Plot 2"


## Visualize the segmented gps data from each messenger
### Raeubertochter

## create own color palette
my_palette <- colorRampPalette(brewer.pal(11, "Spectral"))


## visualiaze raeubertochter deliveries
p_seg_raeubertochter <- ggplot() +
  geom_sf(data = outline, alpha = 0) +
  geom_sf(data = raeubertochter_seg, aes(color = segment_id), size = 0.6) +
   scale_color_manual(values = my_palette(22)) +
  coord_sf(datum = st_crs(2056)) +
  labs(x = "E",
       y = "N") +
    theme_minimal() +
  theme(
    legend.position = "none"
  ) +
  labs(title = "Raeubertochter")


## visualiaze donner deliveries
p_seg_donner <- ggplot() +
  geom_sf(data = outline, alpha = 0) +
  geom_sf(data = donner_seg, aes(color = segment_id), size = 0.6) +
     scale_color_manual(values = my_palette(36)) +
  coord_sf(datum = st_crs(2056)) +
  labs(x = "E",
       y = "N") +
  theme_minimal() +
  theme(
    legend.position = "none"
  ) +
  labs(title = "Donner")


## Arrange both plots together
grid.arrange(p_seg_raeubertochter,p_seg_donner, nrow=1, ncol=2)

```

Subsample of segmented data in a smaller spatial context

```{r visualize segmented data via tmap and spatial context, fig.height=6, fig.width=8, fig.dpi=500}

#| fig-cap: 
#|   - "Line Plot 1"
#|   fig-width: 8
#|   fig-height: 6


### Next, we want to visualize a subsample of our segmented data in a smaller spatial context
## Visualize Subsample in spatial context


## Clip segmented data to a smaller extent to reduce computing time
raeubertochter_ext2 <- st_intersection(raeubertochter_seg, extent_raeubertochter)


## create smaller subsample consisting of every second point to get a better overview
subset_raeubertochter_seg <- raeubertochter_ext2[seq(1, nrow(raeubertochter_ext2), by = 2), ]


## transform segment_id to numeric and back to factor
subset_raeubertochter_seg$segment_id <- as.numeric(subset_raeubertochter_seg$segment_id)
subset_raeubertochter_seg$segment_id <- as.factor(subset_raeubertochter_seg$segment_id)
unique(subset_raeubertochter_seg$segment_id)

## Create own color palette
my_palette2 <- c("#9E0142", "#F46D43", "#FFFF66", "#66C2A5","#3288BD", "#5E4FA2")


tmap_mode("plot")


tm_seg_context <- tm_shape(streets_raeubertochter, bbox = extent_raeubertochter) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing_raeubertochter, bbox = extent_raeubertochter) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(subset_raeubertochter_seg, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.6, col = "segment_id", palette = my_palette2, alpha = 0.7, border.col = "NA", legend.col.show = FALSE) +
  tm_layout(frame = FALSE) 


## Show map
print(tm_seg_context)


## save as png
# tmap_save(tm_seg_context, "raeubertochter_seg.png", width = 250, height = 200, dpi = 250, units = "mm")


```

Visualize raw data via interactive map

```{r visualize segmented data via interactive map}

seg_data <- all_routes_seg[seq(1, nrow(all_routes), by = 2), ]

tmap_mode("view")

tm_shape(raw_data) +
  tm_symbols(size = .25, col = "messenger",  alpha = 0.7, legend.col.show = FALSE, palette = "Spectral", border.col = "black", border.lwd = 0.1) +
  tm_layout(frame = FALSE) +
  tm_basemap(server = "CartoDB.PositronNoLabels", alpha = 0.75) +
  tm_view( symbol.size.fixed = F) +
  tm_facets(by = "messenger", sync = TRUE, ncol = 2)

```

# Task 5: Lost in Transit: Tackling Tunnel GPS Blackouts for Bike Messenger

```{r tackling tunnel gps blackouts}

## problem: we loose gps signal in the bicycle tunnel from enge to sihlhölzli. Our segmentation splits the trajectories into two separate deliveries, even though it's the same route. We try to recognize split segments that we're falsely segmented:
all_routes_seg_tunnel <- all_routes_seg


## extraxt first and last points of each segment
first_last_points <- all_routes_seg_tunnel |> 
  group_by(segment_id) |> 
  slice(c(1, n())) |> 
  ungroup()


## Create entry and exit points at the tunnel. For future project, there might be a data set with tunnel entities, where we could extract the entry and exit points automatically
tunnel_exit <- st_sfc(st_point(c(2682368, 1246996)), crs = 2056)
tunnel_entry <- st_sfc(st_point(c(2682592, 1246751)), crs = 2056)


## create a buffer around the tunnel entry and exit,
# tunnel_points <- st_sfc(tunnel_entry, tunnel_exit, crs = 2056)
buffer_entry <- st_buffer(tunnel_entry, dist = 50)
buffer_exit <- st_buffer(tunnel_exit, dist = 50)


## Identify segments within the buffer
first_last_points_within <- first_last_points |> 
  mutate(
    intersect_start = sapply(st_intersects(geometry, buffer_entry, sparse = FALSE), any),
    intersect_end = sapply(st_intersects(geometry, buffer_exit, sparse = FALSE), any)
  ) |> 
  filter(intersect_start | intersect_end)


## Calculate time difference between end of one segment and start of the next
first_last_points_within <- first_last_points_within |> 
  arrange(segment_id, time) |> 
  mutate(time_diff = time - lag(time))


## Match segments where time difference is less than 2 minutes -> falsely separated segments!
matched_segments <- first_last_points_within |> 
  filter(time_diff <= 120 | is.na(time_diff) ) |> 
  mutate(new_segment_id = lag(segment_id)) |> 
  select(x,y,geometry,time_diff, segment_id, new_segment_id)

## recognize start- and endpoints of segments that lay within the buffer and are only separated by 2 minutes

########## FOR FUTURE PROJECTS -> try to implement matching via segment_id, not time difference! If we make the assumption that we separate trajectories in the tunnel, we can assume that falsely separated segments follow each other. Segments were falsely separated when an endpoint of segment_id 13 and a starting point of segment_id 14 lay within the corresponding buffers. Would be a much cleaner approach! 


## create a table with falsely seperated segment_id's
lookup_table <- matched_segments |> 
  filter(!is.na(new_segment_id) & segment_id != new_segment_id) |> # filter rows where new and old segment_id's do not match
  select(segment_id, new_segment_id)  |> 
  distinct() # replace duplicates


## We recognized one falsely seperated trajecotry. Segment 49 and 50 we're seperated but should be kept together


## In this case, we could merge the segments back together manually. but with larger dataset, this might not be feasible. That's why we try a more general approach:


## create a lookup_vector based on our lookup_table. credits go to: https://stackoverflow.com/questions/35636315/replace-values-in-a-dataframe-based-on-lookup-


## This transforms the lookup table into a vector where the names are segment_id and the values are new_segment_id. This vector will be used to quickly find and replace old segment IDs with new ones.
lookup_vector <- setNames(lookup_table$new_segment_id, lookup_table$segment_id)


## match segment_id's with our lookup_vector. For each segment_id in all_routes_seg_tunnel, it checks if that ID is in the lookup vector. If it is, it replaces it with the corresponding new_segment_id from the lookup vector; if not, it keeps the original segment_id
all_routes_seg_tunnel$segment_id_new <- ifelse(all_routes_seg_tunnel$segment_id %in% names(lookup_vector), lookup_vector[match(all_routes_seg_tunnel$segment_id, names(lookup_vector))], all_routes_seg_tunnel$segment_id)


## tidy up our corrected dataframe
all_routes_seg_tunnel_cor <- all_routes_seg_tunnel |> 
  group_by(segment_id_new, messenger) |> 
  mutate(segment_id_cor = as_factor(cur_group_id())) |> 
  select(-segment_id, -segment_id_new) |> 
  ungroup()


## How many deliveries after the correction?
all_routes_seg_tunnel_cor |> 
  group_by(messenger) |> 
  summarise(length(unique(segment_id_cor)))


## donner with 36 deliveries
## raeubertochter with 21 deliveries


## seperate into raeubertochter
raeubertochter_cor <- filter(all_routes_seg_tunnel_cor, messenger == "raeubertochter")


## and donner
donner_cor <- filter(all_routes_seg_tunnel_cor, messenger == "donner")


```

## Visualize Tunnel Merging

Visualize automated workflow for troubling tunnel problems

```{r visualize corrected segments}

#| fig-cap: 
#|   - "Line Plot 1"
#|   - "Line Plot 2"
#|   - "Line Plot 3"
#|   - "Line Plot 4"

### we want to visualize the correction progress from the original segmentation to the corrected version including our tunnel probelm

tmap_mode("plot")

## create a background for future maps
background <- tm_shape(streets_raeubertochter, bbox = extent_raeubertochter) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing_raeubertochter, bbox = extent_raeubertochter) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
   tm_layout(frame = FALSE) 


## First show segments
p1 <-  background + tm_shape(subset_raeubertochter_seg, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.9, col = "segment_id", palette = my_palette2, alpha = 0.9, border.col = "NA", legend.col.show = FALSE) +
   tm_layout(frame = FALSE, bg.color = "transparent") +
tm_credits("(1)", position = c("RIGHT", "BOTTOM"), size = 1, bg.color = "white", bg.alpha = 0.6)


## Then show start and ending points of trajectories from raeubertochter inside our extent
first_last_points_raeubertochter <- first_last_points |> 
  filter(messenger == "raeubertochter") |> 
  st_intersection(extent_raeubertochter)


p2 <- background + 
tm_shape(subset_raeubertochter_seg, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.9, col = "segment_id", palette = my_palette2, alpha = 0.9, border.col = "NA",legend.col.show = FALSE) +
tm_shape(first_last_points_raeubertochter, bbox = extent_raeubertochter) +
  tm_symbols(size = 2, col = "gold", alpha = 1, border.col = "grey25", border.alpha = 0.5, legend.col.show = F) +
  tm_layout(frame = FALSE, bg.color = "transparent") +
  tm_credits("(1)", position = c("RIGHT", "BOTTOM"), size = 1, bg.color = "white", bg.alpha = 0.6)


## Then show our buffer at the tunnel entry and exit
p3 <- background +  
tm_shape(buffer_entry, bbox = extent_raeubertochter) +
  tm_polygons(col = "red", border.col = "red", lwd = 0.5, alpha = 0.7) +
tm_shape(buffer_exit) +
  tm_polygons(col = "red", border.col = "red", lwd = 0.5, alpha = 0.7)+
tm_layout(frame = FALSE, bg.color = "transparent") +
  tm_credits("(2)", position = c("RIGHT", "BOTTOM"), size = 1, bg.color = "white", bg.alpha = 0.6)


## Then show overlay -> whicht starting and endpoints lay within the entry/exit buffers
p4 <- background + 
tm_shape(buffer_entry, bbox = extent_raeubertochter) +
  tm_polygons(col = "red", border.col = "red", lwd = 0.5, alpha = 0.7) +
tm_shape(buffer_exit) +
  tm_polygons(col = "red", border.col = "red", lwd = 0.5, alpha = 0.7)+
  tm_shape(first_last_points_raeubertochter, bbox = extent_raeubertochter) +
   tm_symbols(size = 2, col = "gold", alpha = 1, border.col = "grey25", border.alpha = 0.5, legend.col.show = F) +
  tm_layout(frame = FALSE, bg.color = "transparent") +
  tm_credits("(3)", position = c("RIGHT", "BOTTOM"), size = 1, bg.color = "white", bg.alpha = 0.6)


## then show unmerged/merged results
## unmerged
p5 <- background +
  tm_shape(subset_raeubertochter_seg, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.6, col = "segment_id", palette = my_palette2, alpha = 0.7, border.col = "NA", legend.col.show = FALSE) +
  tm_layout(frame = FALSE, bg.color = "transparent") 


## Adapt color palette to less segments
my_palette3 <- c("#9E0142", "#F46D43", "#FFFF66", "#3288BD",  "#5E4FA2")


## merged
subset_raeubertochter_cor <- raeubertochter_cor[seq(1, nrow(raeubertochter_cor), by = 2), ]
subset_raeubertochter_cor <- st_intersection(subset_raeubertochter_cor, extent_raeubertochter)

subset_raeubertochter_cor$segment_id_cor <- as.numeric(subset_raeubertochter_cor$segment_id_cor)
subset_raeubertochter_cor$segment_id_cor <- as.factor(subset_raeubertochter_cor$segment_id_cor)


p6 <- background + 
tm_shape(subset_raeubertochter_cor, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.9, col = "segment_id_cor", palette = my_palette3, alpha = 0.9, border.col = "NA", legend.col.show = FALSE) +
  tm_layout(frame = FALSE, bg.color = "transparent") +
  tm_credits("(4)", position = c("RIGHT", "BOTTOM"), size = 1, bg.color = "white", bg.alpha = 0.6)


## show merged segments
#print(p6)

## save to png 
#tmap_save(p6, "raeubertochter_cor.png", width = 250, height = 200, dpi = 250, units = "mm")


## arrange in a 2x2 grid for our working progress
p_arrange_tunnel_workflow <-  tmap_arrange(p2, p3, p4, p6, ncol = 2, nrow = 2)


## print working progress
print(p_arrange_tunnel_workflow)


## save as png
# tmap_save(p_arrange_tunnel_workflow, "tunnel_workflow.png", width = 500, height = 400, dpi = 250, units = "mm")



```


# Task 6: Creating alternative trajectories with hereR:route()

```{r alternative routing}

## Extract starting and endpoints from real world trajecotries
a_to_b <- all_routes_seg_tunnel_cor |> 
  group_by(segment_id_cor) |> 
  slice(c(1, n())) |> 
  ungroup()


## quick and dirty overview
tmap_mode("plot")
tm_shape(a_to_b) + 
  tm_dots(col = "blue", size = .25) +
  tm_layout(frame = FALSE)


## Get accsess to API from here, this API will later generate our alternative routes based on the start and endpoints of the deliveries
library("hereR")
set_key("PARpVmlSSQAeuGjMhIdg94LMi9s1ha4UShazq0j8sAo")


############### ATTENTION: We get a lot of warning due to our limited access to this API. We're barely able to get 1 alternative route per delivery for 1 shift per messenger. We have access to almost 60 shifts per messenger, but can not generate an alternative for one shift per messenger, major bummer! We try to run the function (route) twice, ones for raeubertochter, ones for donner so at least for day one, all routes get an alternative

## Create a dataframe with even rows -> ENDPOINTS
df_even <- a_to_b[seq(2, nrow(a_to_b), by = 2), ]
# df_even_raeubertochter <- filter(df_even, messenger == "raeubertochter")
# df_even_donner <- filter(df_even, messenger == "donner")

# if a single smaple is needed
#df_even <- filter(df_even, segment_id_cor == 57)


## Create a dataframe with odd rows -> STARTING POINTS
df_odd <- a_to_b[seq(1, nrow(a_to_b), by = 2), ]
# df_odd_raeubertochter <- filter(df_odd, messenger == "raeubertochter")
# df_odd_donner <- filter(df_odd, messenger == "donner")

# if a single smaple is needed
#df_odd <- filter(df_odd, segment_id_cor == 57)

alternative_lines <- route(origin = df_odd, destination = df_even, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "short")



## create an alternative route for every single delivery from raeubertochter
# alternative_lines_donner <- route(origin = df_odd_donner, destination = df_even_donner, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "short")
# 
# ## create an alternative route for every single delivery from raeubertochter
# alternative_lines_raeubertochter <- route(origin = df_odd_raeubertochter, destination = df_even_raeubertochter, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "short")


############### We still get warning because we sent too many request in a given time frame. We will compute the alternatives with a little pause in between so we can get alternatives for all routes on day one.


## Combine datasets back together
#alternative <- rbind(alternative_lines_donner, alternative_lines_raeubertochter)


## Transform alternative in spatial point dataframe
alternative <- alternative_lines |> 
  st_transform(crs = 2056) |> 
  st_cast("POINT") |> 
  st_zm(drop = TRUE) |> 
  rename(segment_id = id)


## drop height information, well add id back later via dhm25
alternative <- st_zm(alternative, drop = TRUE)



```
